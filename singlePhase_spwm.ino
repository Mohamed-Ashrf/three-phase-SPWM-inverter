#define bit_get(p,m) ((p) & (m))
#define bit_set(p,m) ((p) |= (m))
#define bit_clear(p,m) ((p) &= ~(m))
#define bit_flip(p,m) ((p) ^= (m))
#define bit_write(c,p,m) (c ? bit_set(p,m) : bit_clear(p,m))
#define BIT(x) (0x01 << (x))
#define LONGBIT(x) ((unsigned long)0x00000001 << (x))

#include <avr/io.h>
#include <avr/interrupt.h>


float universal_lookup[] = { 0.00 , 0.01 , 0.02 , 0.03 , 0.04 , 0.05 , 0.06 , 0.07 , 0.08 , 0.09 , 0.10 , 0.11 , 0.13 , 0.14 , 0.15 , 0.16 , 0.17 , 0.18 , 0.19 , 0.20 , 0.21 , 0.22 , 0.23 , 0.24 , 0.25 , 0.26 , 0.27 , 0.28 , 0.29 , 0.30 , 0.31 , 0.32 , 0.33 , 0.34 , 0.35 , 0.36 , 0.37 , 0.38 , 0.39 , 0.40 , 0.41 , 0.42 , 0.43 , 0.44 , 0.44 , 0.45 , 0.46 , 0.47 , 0.48 , 0.49 , 0.50 , 0.51 , 0.52 , 0.53 , 0.54 , 0.54 , 0.55 , 0.56 , 0.57 , 0.58 , 0.59 , 0.60 , 0.60 , 0.61 , 0.62 , 0.63 , 0.64 , 0.65 , 0.65 , 0.66 , 0.67 , 0.68 , 0.68 , 0.69 , 0.70 , 0.71 , 0.71 , 0.72 , 0.73 , 0.74 , 0.74 , 0.75 , 0.76 , 0.76 , 0.77 , 0.78 , 0.78 , 0.79 , 0.80 , 0.80 , 0.81 , 0.82 , 0.82 , 0.83 , 0.83 , 0.84 , 0.84 , 0.85 , 0.86 , 0.86 , 0.87 , 0.87 , 0.88 , 0.88 , 0.89 , 0.89 , 0.90 , 0.90 , 0.90 , 0.91 , 0.91 , 0.92 , 0.92 , 0.93 , 0.93 , 0.93 , 0.94 , 0.94 , 0.94 , 0.95 , 0.95 , 0.95 , 0.96 , 0.96 , 0.96 , 0.97 , 0.97 , 0.97 , 0.97 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.97 , 0.97 , 0.97 , 0.97 , 0.96 , 0.96 , 0.96 , 0.95 , 0.95 , 0.95 , 0.94 , 0.94 , 0.94 , 0.93 , 0.93 , 0.93 , 0.92 , 0.92 , 0.91 , 0.91 , 0.90 , 0.90 , 0.90 , 0.89 , 0.89 , 0.88 , 0.88 , 0.87 , 0.87 , 0.86 , 0.86 , 0.85 , 0.84 , 0.84 , 0.83 , 0.83 , 0.82 , 0.82 , 0.81 , 0.80 , 0.80 , 0.79 , 0.78 , 0.78 , 0.77 , 0.76 , 0.76 , 0.75 , 0.74 , 0.74 , 0.73 , 0.72 , 0.71 , 0.71 , 0.70 , 0.69 , 0.68 , 0.68 , 0.67 , 0.66 , 0.65 , 0.65 , 0.64 , 0.63 , 0.62 , 0.61 , 0.60 , 0.60 , 0.59 , 0.58 , 0.57 , 0.56 , 0.55 , 0.54 , 0.54 , 0.53 , 0.52 , 0.51 , 0.50 , 0.49 , 0.48 , 0.47 , 0.46 , 0.45 , 0.44 , 0.44 , 0.43 , 0.42 , 0.41 , 0.40 , 0.39 , 0.38 , 0.37 , 0.36 , 0.35 , 0.34 , 0.33 , 0.32 , 0.31 , 0.30 , 0.29 , 0.28 , 0.27 , 0.26 , 0.25 , 0.24 , 0.23 , 0.22 , 0.21 , 0.20 , 0.19 , 0.18 , 0.17 , 0.16 , 0.15 , 0.14 , 0.13 , 0.11 , 0.10 , 0.09 , 0.08 , 0.07 , 0.06 , 0.05 , 0.04 , 0.03 , 0.02 , 0.01 };
int steps = 300;
long int pot_value = 0;
int frequancy = 1;
long long int BASE_icr = 0;
long int counter = 0;
double mod_idx = 1;
void action();

void setup() {


  Serial.begin(9600);
  

  TCCR1A=0b10100010;   //TIMER1 Fast PWM non invert
  TCCR1B=0b00011001;   //per-scaler 1
  TIMSK1=0b00000001;   //enabling overflow INT

  pinMode(2,1);
  pinMode(9,1);
  pinMode(10,1);
  

  ICR1=1600;
  sei();
  frequancy = 1;
  mod_idx = 1;

}

void loop() {
  
  LOOP_action();

}



ISR(TIMER1_OVF_vect){
  action();
}

void action(){
  
  counter++;

  if( counter > steps ){
    bit_flip(PORTD, BIT(2));
    counter = -1;
    frequancy = map(analogRead(A0), 0, 1023, 1, 150);
    //mod_idx = map(analogRead(A1), 0, 1023, .1, 1);
  }

}

void LOOP_action(){
  BASE_icr = floor(((16e6)/(300*frequancy))-1);
  ICR1=BASE_icr/2;
  mod_idx = ICR1*mod_idx;
  OCR1A= universal_lookup[counter]*ICR1;
  Serial.println(frequancy);
  //Serial.print("-");
  //Serial.println(mod_idx);
  
  
  }
    
